const aws = require("aws-sdk");
const dbg = require("debug");
const dynamodb = new aws.DynamoDB();
const helpers = require("./airthingsapi-helpers");
const Kinesis = require("aws-sdk").Kinesis;
const luxon = require("luxon");
const moment = require("moment");
const url = require("url");
const log = require("debug")("airthingsapipoller.func.main");

log.log = console.log.bind(console);

/**
 * Gets all devices from locations data
 * @param {Object} locations Airthings API location object
 * @returns {Array} array of devices with long/lat
 */
function getDevices(locations) {
    const devices = [];
    locations.forEach((location) => {
        const devdata = location.devices.map((device) => {
            return Object.assign({}, device, {
                "lng": location.lng,
                "lat": location.lat
            });
        });
        for (let index = 0; index < devdata.length; index++) {
            const element = devdata[index];
            devices.push(element);
        }
    });
    return devices;
}

/**
 * Gets the devices sensors data as streamable results
 * @param {Array} locationDevices devices by location aray
 * @param {Array} devicesData data generated by devices identified by segment
 * @returns {Array} sensors data as streamable results
 */
function getStreamableDeviceData(locationDevices, devicesData) {
    const data = [];
    locationDevices.forEach((locationDevice) => {
        log(`using device ${JSON.stringify(locationDevice)}`);
        const segmentId = locationDevice.segmentId;
        log(`searching for segmentId ${segmentId}`);
        const deviceBySegments = devicesData.filter((deviceData) => {
            log(`testing against ${deviceData.segmentId} ${deviceData.segmentId === segmentId}`);
            return deviceData.segmentId === segmentId;
        });
        log(`device segment ${JSON.stringify(deviceBySegments)}`);
        const deviceBySegment = deviceBySegments[0];
        if (deviceBySegment) {
            for (let index = 0; index < deviceBySegment.sensors.length; index++) {
                const sensorData = deviceBySegment.sensors[index];
                const offsetType = sensorData.offsetType;
                const offsets = deviceBySegment.offsets[offsetType];
                for (let offsetIndex = 0; offsetIndex < offsets.length; offsetIndex++) {
                    const offset = offsets[offsetIndex];
                    data.push({
                        "deviceid": locationDevice.serialNumber,
                        "timestamp": luxon.DateTime.utc().toISO(),
                        "sensortype": sensorData.type,
                        "sensorvalue": sensorData.measurements[offsetIndex],
                        "sensortimestamp": luxon.DateTime.fromISO(deviceBySegment.segmentStart).plus({ "seconds": offset })
                    });
                }
            }
        }
    });
    return data;
}

exports.main = async function (event, context) {
    log("starting lambda function");
    const stream = new Kinesis();
    const environment = process.env.ENVIRONMENT || "dev";
    const result = await dynamodb.query({
        "ExpressionAttributeValues": {
            ":v1": {
                "S": "password"
            }
        },
        "TableName": `airthingsapipoller-loginsdata-${environment}`,
        "KeyConditionExpression": "login_type = :v1"
    }).promise();
    return Promise.all(result.Items.map(async (item) => {
        log(`fetching for login ${JSON.stringify(item)}`);
        const username = item.username;
        const password = item.password;
        const identityToken = await helpers.getIdentityTokens(username.S, password.S);
        const authorizationCodeUrl = await helpers.getAutorizationCodeUrl(identityToken.access_token);
        const authCode = url.parse(authorizationCodeUrl.redirect_uri, true).query.code;
        const accessToken = await helpers.getAccessTokenFromAuthorizationCode(authCode);
        const locationData = await helpers.getLocationData(accessToken);
        const thresholdsData = await helpers.getThresholdsData(accessToken);
        const relayData = await helpers.getRelayDevicesData(accessToken);
        const devices = [];
        relayData.hubs.forEach((hub) => {
            const deviceKeys = Object.keys(hub.metaData.devices);
            for (let index = 0; index < deviceKeys.length; index++) {
                const element = deviceKeys[index];
                devices.push(element);
            }
        });
        const from = luxon.DateTime.utc()
            .minus({"hours": 1})
            .toISO();
        const to = luxon.DateTime.utc()
            .plus({"day": 1})
            .toISO();
        const devicesData = await Promise.all(
            devices.map((deviceId) => {
                return helpers.getDeviceSegmentsData(accessToken, deviceId, from, to);
            }));
        const data = Object.assign({}, locationData, { "devices": devicesData });
        log(`data captured ${JSON.stringify(data)}`);
        const locationDevices = getDevices(data.locations);
        log(`devices captured ${JSON.stringify(locationDevices)}`);
        const streamableDeviceData = getStreamableDeviceData(locationDevices, data.devices);
        log(`stream data captured ${JSON.stringify(streamableDeviceData)}`);
        await Promise.all(streamableDeviceData.map((streamData) => {
            log(`putting record ${JSON.stringify(streamData)}`);
            return stream.putRecord({
                "Data": JSON.stringify(streamData),
                "PartitionKey": "airthingapi",
                "StreamName": `sensorsdata-stream-${environment}`,
            }).promise();
        }));
        return Promise.resolve(data);
    }));
};